
\section{Որոնման բինար ծառ}

\emph{Բինար ծառը} տվյալների դինամիկ կառուցվածք է, որը 
կամ \textbf{i․}~դատարկ է՝ \(\boxslash\), կամ 
\textbf{ii․}~հանգույց է, որն ունի \emph{բանալու} դեր 
կատարող \emph{data} դաշտը, և \emph{ձախ} ու \emph{աջ} 
ենթածառերին հղվող երկու ցուցիչներ՝ \emph{left} և 
\emph{right}։ Այդ հանգույցն ընդունված է պատկերել 
նկ․~\ref{fig:bst-1}֊ում բերված տեսքով։

\begin{figure}[h]
\centering
\includegraphics{struc-fig-21.eps}
\caption{Որոնման բինար ծառի հանգույցը։}
\label{fig:bst-1}
\end{figure}

\emph{Որոնման բինար ծառում} ամեն մի հանգույցի պարունակած 
արժեքը՝ բանալին, ունի ավելի մեծ \emph{կարգ}, քան նրա ձախ 
ենթածառի բոլոր արժեքները, և ունի ավելի փոքր կարգ, քան նրա 
աջ ենթածառի բոլոր արժեքները։ Օրինակ, 
\(a_0\prec a_1\prec\ldots\prec a_5\),
արժեքները պարունակող որոնման բինար ծառը 
կունենա նկ․~\ref{fig:bst-2}֊ում պատկերված տեսքը։
\begin{figure}[h]
\centering
\includegraphics{struc-fig-22.eps}
\caption{\(a_0\prec\ldots\prec a_5\) արժեքները պարունակող 
որոնման բինար ծառը։}
\label{fig:bst-2}
\end{figure}
(Այստեղ օգտագործված է «\(\prec\)» հարաբերությունը ընդգծելու 
համար, որ \(a_i\) արժեքները կարող են լինել ցանկացած 
կարգավորված բազմության տարրեր։)

Եթե ծառի մի որևէ հանգույցի \emph{left} և \emph{right} 
ցուցիչներն ունեն \(\boxslash\) արժեքը (\emph{զրոյական} 
են), ապա այդ հանգույցը կոչվում է \emph{տերև}, հակառակ 
դեպքում՝ \emph{ներքին} հանգույց։ Եթե \(a_j\) հանգույցը 
կապված է \(a_i\) հանգույցի \emph{left} կամ \emph{right} 
ցուցյչներից որևէ մեկին, ապա \(a_j\)֊ն կոչվում է \(a_i\)֊ի 
\emph{ժառանգ}, իսկ \(a_i\)֊ն՝ \(a_j\)֊ի \emph{ծնող}։ Եթե 
ծնող հանգույցը գտնվում է ծառի \(n\)֊րդ \emph{մակարդակում}, 
ապա ժառանգ հանգույցները (բինար ծառի դեպքում դրանք կարող 
են լինել երկուսը) գտնվում են \(n+1\) մակարդակում։ \(0\)֊րդ
մակարդակում (ամենավերևում) գտնվող հանգույցը կոչվում է
\emph{արմատ}։  

%
%
\subsection{\texttt{BinarySearchTree} դասը}
Որոնման բիբար ծառն իրականացված է \texttt{BinarySearchTree}
ընդհանրացված դասով, որի \texttt{E} տիպի պարամետրը 
\emph{համեմատելի} է։ (Java լեզվում այդ պահանջը նշվում է 
տիպի պարամետրից պահանջելով, որ այն լինի մի որևէ 
\texttt{Comparable} տիպի ընդլայնում։)
Որպես գործողություններ նախատեսված են․ 
\textbf{i․}~ծառում տարր ավելացնելը, 
\textbf{ii․}~տրված արժեքով տարրի որոնումը, 
\textbf{iii․}~տրված արժեքով հանգույցի հեռացնելը և 
\textbf{iv․}~հանգույցների թվարկում՝ տարբեր կարգերով։
<<BinarySearchTree դասը>>=
package structures;
import java.util.function.Consumer;
public class BinarySearchTree<E extends Comparable<E>> {
  <<Բինար ծառի հանգույցը>>
  <<Ծառի արմատը>>
  <<Դատարկ ծառ>>
  <<Տարրի ավելացնելը>>
  <<Տրված տարրի որոնումը>>
  <<Անցում բոլոր հանգույցներով>>
  <<Տարրի հեռացնելը>>
}
@ 
Վերը նշվեց, որ ծառը ռեկուրսիվ կառուցվծքով օբյեկտ է։ Դա 
հնարավորություն է տալիս, իսկ ինչ֊որ տեղ նաև պահանջում է, 
նրա հետ կատարվող բոլոր գործողությունների ալգորիթմներն 
իրկանացնել ռեկուրսիվ եղանակով։ Նույն գործողությունների 
իտերատիվ իրականացումները թեև շատ բարդ չեն, սակայն իրենց
տեխնիկական քայլերով հաճախ մշուշոտ են դարձնում ալգորիթմի
բուն էությունը։ 

%
\paragraph{Բինար հանգույցը։} 
Որոնման բինար ծառը բաղկացած է բինար հանգույցներից, որոնք
նկարագրվում են \texttt{Node} ներդրված դասով։ Այն ունի 
չորս բաղադրիչներ՝ հետևյալ նշանակությամբ․ 
\texttt{data} -- տվյալներ (բանալի),
\texttt{count} -- նույն արժեքներով տարրերի հաշվիչ,
\texttt{left} և \texttt{right} -- ձախ և աջ ենթածառերի ցուցիչ։
Երբ փորձ է արվում ծառում ավելացնել նույն արժեքով երկու տարր,
ապա, պարզ է, որ կարիք չկա նոր հանգույց ավելացնել, այլ պետք է
պարզապես մեծացնել \texttt{count} հաշվիչը։
<<Բինար ծառի հանգույցը>>=
protected class Node {
  public E data = null;
  public int count = 1;
  public Node left = null;
  public Node right = null;

  public Node(E d)
  {
    data = d;
  }
}
@
Իսկ \texttt{BinarySearchTree} դասում ծառի \emph{արմատը} նշվում 
է \texttt{Node} տիպի \texttt{root} ցուցիչով․
<<Ծառի արմատը>>=
protected Node root = null; 
@
Եթե արմատի արժեքը \(\boxslash\) է, ապա կասենք, որ ծառը \emph{դատարկ} է․
<<Դատարկ ծառ>>=
public boolean isEmpty()
{
  return null == root;
}
@
?

%
\paragraph{Տարր ավելացնելը։}
Որոնման բինար ծառում նոր հանգույց ավելացնելու համար նախ 
պետք է ճշգրտել դրա ավելացնելու տեղը։ Դիտարկենք, օրինակ, 
\(a_0\prec a_1\prec\ldots\prec a_5\) կարգավորված շարքը
պարունակող ծառը (նկ․~\ref{fig:bst-3})։
\begin{figure}[h]
\centering
\includegraphics{struc-fig-23.eps}
\caption{\(e\) տարիի ավելացնելը \(a_0\prec\ldots\prec a_5\)
արժեքները պարունակող ծառում։}
\label{fig:bst-3}
\end{figure}
Ապա ենթադրենք, թե այդ ծառում պետք է ավելացնել \(e\) 
արժեքը, որը հաջորդում է \(a_3\)֊ին և նախորդում է 
\(a_4\)֊ին՝ \(a_3\prec e\prec a_4\)։ Ակնհայտ է, որ 
\(e\) արժեքով հանգույցը պետք է ավելացնել որպես \(a_3\)
հանգույցի աջ տերև։ Նկ․~\ref{fig:bst-3}֊ի աջ կողմում թավ 
գծերով ցույց է տրված, թե ինչ ճանապարհ է անցել նոր 
ավելացվող արժեքը՝ իր տեղը որոնելու ժամանակ։

\texttt{insert(e,r)} օժանդակ ռեկուրսիվ մեթոդը ստանում է 
ծառում ավելացվելիք \texttt{e} արժեքն ու ծառի \texttt{r} 
արմատը, և վերադարձնում է նույն ծառը, բայց արդեն ավելացված 
(կամ հաշվիչը փոփոխված) հանգույցով։ 
Հնարավոր են հետևյալ չորս դեպքերը․ 
\textbf{i․}~երբ ծառը \emph{դատարկ} է՝ \(r\equiv\boxslash\), ապա 
ստեղծվում է \(e\) արժեքով նոր հանգույց և այն վերադարձվում 
է որպես ձևափոխված ծառ,  
\textbf{ii․}~երբ տրված արժեքը \emph{նախորդում} է ծառի արմատում 
գրված արժեքին՝ \(e\prec r.data\), ապա ավելացնելու գործողությունը 
ռեկուրսիվ կիրառվում է ծառի ձախ ենթածառի նկատմաբ, 
\textbf{iii․}~եթե տրված արժեքը \emph{հաջորդում} է ծառի 
արմատում գրված արժեքին՝ \(r.data\prec e\), ապա ավելացնելու 
գործողությունը ռեկուրսիվ կիրառվում է աջ ենթածառի նկատմամբ, 
և վերջապես \textbf{iv․}~եթե տրված և արմատում գրված արժեքները 
\emph{հավասար} են՝ \(e\equiv r.data\), ապա պարզապես մեկով 
ավելացվում է հաշվիչի արժեքը։ 
<<Տարրի ավելացնելը>>=
private Node insert(E e, Node r)
{
  if( r == null )
    return new Node(e);

  int cmp = e.compareTo(r.data);
  if( cmp < 0 )
    r.left = insert(e, r.left);
  else if( cmp > 0 )
    r.right = insert(e, r.right);
  else
    ++r.count;

  return r;
}
@
Սա օժանդակ \texttt{private} մեթոդ էր։ Որոնման բինար ծառի
ինտերֆեյսային \texttt{insert(e)} մեթոդում այն պետք է կիրառել
ծառի արմատի նկատմամբ և վերադարարծ արժեքն էլ վերագրել ծառի 
արմատին։
<<Տարրի ավելացնելը>>=
public void insert(E e)
{
  root = insert(e, root);
}
@

%
%
\paragraph{Արժեքի որոնելը։}
Որոնման բինար ծառում մի որևէ տրված արժեքի որոնելը 
նույնպես կատարվում է օժանդակ ռեկուրսիվ մեդոդի օգնությամբ․
<<Տրված տարրի որոնումը>>=
public boolean contains(E e)
{
  return contains(e, root);
}
@
Այս \texttt{contains(e,r)} մեթոդը ստանում է որոնվող արժեքը 
և ծառի արմատը, որում պետք է կատարել որոնումը։ Պարզ է, որ 
դատարկ ծառի համար որոնումը բացասական պատասխան է տալու։
Այնուհետև պետք է դիտարկել երեք դեպքեր․ \(e\prec r.data\),
\(e\succ r.data\) և \(e\equiv r.data\)։ Առաջին դեպքի 
համար որոնումը պետք է շարունակել ձախ ենթածառում, երկրորդ
դեպքի համար՝ աջ ենթածառում, իսկ երրորդ դեպքը հանդիպելիս
պետք է ասել, որ որոնվող արժեքը հայտնաբերվել է ծառում։  
<<Տրված տարրի որոնումը>>=
private boolean contains(E e, Node r)
{
  if( r == null )
    return false;

  int cmp = e.compareTo(r.data);
  if( cmp < 0 )
    return contains(e, r.left);
  if( cmp > 0 )
    return contains(e, r.right);

  return true;
}
@


%
\paragraph{Տարրի հեռացնելը։}
Որոնման բինար ծառից տրված արժեքը պարունակող հանգույցը
հեռացելուց հետո ծառը պետք է պահպանի իր՝ ըստ սահմանման 
որոշված հատկությունները․ կամայական գագաթի ձախ ենթածառի
բոլոր արժեքները պետք է նախորդեն դիտատկվող գագաթում 
գրանցված արժեքին, իսկ աջ ենթածառի արժեքները՝ հաջորդեն։

\texttt{remove(e,r)} որոնող֊հեռացնղ օժանդակ մեթոդը 
ստանում է \texttt{e} հեռացվելիք արժեքն ու ծառի \texttt{r} 
արմատը, և վերադարձնում է նույն ծառը, բայց առանց \texttt{e}֊ն 
պարունակող հանգույցի։
<<Տարրի հեռացնելը>>=
public void remove(E e)
{
  root = remove(e, root);
}
@ 
Ինչպես միշտ, նախ դիտարկվում է դատարկ ծառը․ այդ դեպքում 
հեռացնելու բան չկա և պետք է վերադարձնել \(\boxslash\)։ 
Այնուհետև որոնել֊հեռացնելու գործողությունը շարունակվում 
է կա՛մ ձախ ենթածառում, կա՛մ աջ ենթածառում՝ կախված նրանից, 
թե \(e\)֊ն ինչ հարաբերության մեջ է ծառի արմատում գրված 
արժեքի հետ։ Երբ որոնել֊հեռացնելու գործողությունը 
\(e\equiv r.data\) պայմանով կանգ է առնում մի որևէ հանգույցի 
վրա, ապա դա էլ հենց հեռացվելու թեկնածուն է։
<<Տարրի հեռացնելը>>=
private Node remove(E e, Node r)
{
  if( r == null )
    return null;

  int cmp = e.compareTo(r.data);
  if( cmp < 0 )
    r.left = remove(e, r.left);
  else if( cmp > 0 )
    r.right = remove(e, r.right);
  else {
    <<Հեռացնել հանգույցը>>
  }

  return r;
}
@ 
(Այստեղ \texttt{remove(e,r)} մեթոդի ռեկուրսիվ կանչը, 
օրինակ, ձախ ենթածառի համար ունի 
\texttt{r.left = remove(e, r.left)} տեսքը։ Սա նշանակում 
է․ «\texttt{e}-ն հեռացնել \texttt{r}֊ի ձախ ենթածառից և 
ձևափոխված ենթածառը նորից կապել \texttt{r.left} ցուցիչին»։)

Երբ հեռացվելու թեկնածու հանգույցը հայտնաբերված է, պետք 
է դիտարկել նրա տեղադրության չորս դեպքեր (նկ․~\ref{fig:bst-4})․ 
\textbf{i․}~հանգույցը տերև է, 
\textbf{ii․}~նրա աջ ենթածառը դատարկ է, 
\textbf{iii․}~նրա ձախ ենթածառը դատարկ է, 
\textbf{iv․}~նրա երկու ենթածառերն էլ առկա են։
\begin{figure}[h]
\centering
\includegraphics{struc-fig-24.eps}
\caption{Հեռացվող հանգույցի չորս հնարավոր դիրքերը։}
\label{fig:bst-4}
\end{figure}

Երկու բուլյան փոփոխականներ՝ \texttt{L} և \texttt{R}, ցույց 
են տալիս համապատասխանաբար հանգույցի ձախ և աջ ենթածառերի 
առկայությունը։ Օգտագործելով դրանք՝ հերթով կդիտարկենք 
հանգույցը հեռացնելու բոլոր չորս դեպքերը։
<<Հեռացնել հանգույցը>>=
boolean L = r.left != null;
boolean R = r.right != null;
<<Հեռացնել տերևը>>
<<Աջ ենթածառը դատարկ է>>
<<Ձախ ենթածառը դատարկ է>>
<<Աջ ու ձախ ենթածառերն առկա են>>
@
Տերևը հեռացնելու դեպքը շատ պարզ է․ դրա փոխարեն պետք է 
վերադարձնել \(\boxslash\)։
<<Հեռացնել տերևը>>=
if( !L && !R )
  return null;
@
Երբ դատարկ է հեռացվող հանգույցի աջ ենթածառը, ապա որպես 
արդյունք պետք է վերադարձնել ձախ ենթածառը։ 
<<Աջ ենթածառը դատարկ է>>=
if( L && !R )
  return r.left;
@
Երբ դատարկ է հեռացվող հանգույցի ձախ ենթածառը, ապա որպես
արդյուք պետք է վերադարձնել աջ ենթածառը։
<<Ձախ ենթածառը դատարկ է>>=
if( !L && R )
  return r.right;
@
Այն դեպքում, երբ հեռացվող հանգույցի աջ ու ձախ ենթածառերն
առկա են, հեռացվող հանգույցի 
պետք է զբաղեցնի կա՛մ
կարգով դրան նախորդող, կա՛մ կարգով դրան հաջորդող արժեքը։ 
աջ ենթածառի ամենաձախ հանգույցը, կամ ձախ ենթածառի ամենաաջ
հանգույցը․ միայն այդ դեպքում կպահպանվեն որոնման բինար ծառի 
հատկությունները։ 
<<Աջ ու ձախ ենթածառերն առկա են>>=
Node p = r.right;
while( p.left != null )
  p = p.left;
r.data = p.data;
r.right = remove(p.data, r.right);
@
  
Դիտարկենք \(A\), \(\ldots\), \(J\) տառերը պարունակող որոնման 
բինար ծառը, որից հաջորդաբար հեռացվում են \(D\), \(F\) և 
\(G\) տառերը պարունակող հանգույցները։ 
\begin{figure}[h]
\centering
\includegraphics{struc-fig-25.eps}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics{struc-fig-26.eps}
\end{figure}



%
%
\paragraph{Անցում ծառի հանգույցներով։}
Ծառում տվյալներ կուտակելուց բացի մեզ պետք է լինում նաև 
ինչ֊որ կերպ օգտագործել այդ տվյալները։ Այսինքն պետք է 
միջոց, որի օգնությամբ կարողանանք թվարկել ծառում պահվող 
բոլոր արժեքները։ Թվարկման մեթոդները երեքն են․ \emph{prefix}, 
\emph{infix} և \emph{postfix}։ Այս տերմինների pre, in և 
post նախնիրները ցույց են տալիս, որ թվարկումը պետք է սկսել 
համապատասխանաբար ձախ ենթածառից, գակաթից կամ աջ ենթածառից։ 
Հեշտ հիշելու համար այս երեք անցումները անվանում են նաև 
\emph{գագաթ֊ձախ֊աջ}, \emph{ձախ֊գագաթ֊աջ} և 
\emph{ձախ֊աջ֊գագաթ} անցումներ։ Անցման նշված կարգերը 
սահմանենք թվարկման տարրերի տեսքով․
<<Անցում բոլոր հանգույցներով>>=
public enum Order { Prefix, Infix, Postfix }
@
Իսկ \texttt{traverse} մեթոդը ունի երկու պարամետր․ մեկն 
այն գործողությունն է, որ պետք է կատարել հանգույցում 
պահվող արժեքի հետ, իսկ մյուսը անցման կարգի տարբերիչն է․
<<Անցում բոլոր հանգույցներով>>=
public void traverse(Consumer<E> f, Order ord)
{
  traverse(f, root, ord);
}
@ 
Բոլոր երեք անցումները մոդելավորելու համար գրված է մեկ 
մեթոդ։ Քանի որ անցման կարգը որոշող \texttt{ord} պարամետրը 
կարող է ընդունել \texttt{Order} թվարկման արժեքներից միայն 
մեկը, \texttt{traverse} մեթոդի մարմնում prefix, infix և 
postfix անցումներին համապատասխան գործողությունները 
ստուգվում են երեք անկախ պայմաններով․
<<Անցում բոլոր հանգույցներով>>=
public void traverse(Consumer<E> f, Node r, Order ord)
{
  if( r != null ) {
    if( Order.Prefix == ord )
      f.accept(r.data);

    traverse(f, r.left, ord);

    if( Order.Infix == ord )
      f.accept(r.data);

    traverse(f, r.right, ord);

    if( Order.Postfix == ord )
      f.accept(r.data);
  }
}
@


%
%
\subsection{Հավանականային բառարան}



